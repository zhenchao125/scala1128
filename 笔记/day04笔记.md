# Day04笔记

## 1. 复习

hash值:  默认情况是通过一种hash算法, 得到一个值, 这个值就是将来对象在堆内存中的值.

`hashCode`这个方法, 默认返回了这个`hash`值, 

自定义类的时候, 一般为了比较两个对象是否相等,一般会覆写这个方法, 一旦覆写, 这和内存地址就没有任何关系了.

System类中, 提供了一个方法, 可以获取对象原始的hash值(内存地址)`System.identityHashCod`

### 名调用换个无参函数的区别

```scala
def main(args: Array[String]): Unit = {
    // 1. 调用时
    foo1{
        println(" => Int  .....")
        1
    }
    foo2(() => {
        println(" () => Int")
        1
    })
}

def foo1(f:  => Int) = {
   val i =  f  // 表示执行传过来的代码块
    println(i)
    f
}

def foo2(f:() => Int) = {
    f()
}
```

### 高阶函数

定义

自定义了几个高阶函数 `filter, foreach, map, reduce`

闭包  一个函数和这个函数的环境(他访问到的外部的变量), 闭包可以延长局部遍历的生命周期, 而且可以实现了在函数的尾部访问到了函数的局部遍历

柯里化  把一个参数列表中的多个参数, 变成多个参数列表,  柯里化.  后期用的特别多, 可以简化函数的调用.

匿名函数   

匿名函数的传递 简化

名调用和值调用

控制抽象(名调用的使用)  能看懂别人在使用

递归   一定要清楚你这个函数在干什么, 参数表示什么含义, 返回值表示什么含义.  最好把注释写明白

尾递归 找到累计器

## 2. 函数和方法的区别

```
方法和函数的区别:
1. 定义方式不一样
    a: 方法定义
        def 方法名(参数类别): 返回值类型 = {  // 方法的实现}
        
        def foo(a: Int, b:Int) = {
        
        }
    b: 函数定义
        (参数列表) => { //函数体}
        (a: Int, b:Int) => a + b
        
2. 有匿名函数, 但是没有匿名方法
      匿名函数   (a: Int, b:Int) => a + b
      
3. 函数也可以有名字
      val/var f: (Int, Int) => Int = (a: Int, b: Int) => a + b
      f就是函数名

4. 方法调用的时候, 如果参数只有一个或者没有参数则圆括号可以省略
    函数的圆括号不能省略
    
    // foo2是方法
    MethodFunction foo2 10
    MethodFunction.foo2(10)
    this foo2 10

    // f1是函数, 则调用的不能省略圆括号
    val f1 = () => println("无参函数...")
    f1()
5.  函数可以作为值传递和作为返回值返回, 但是方法不行
        换句话说, 在给高阶函数传递参数的时候, 只能传函数, 不能传方法.

6. 在使用的时候, 不产生歧义的情况下, scala会自动的根据需要把方法转成函数!!!
    手动转:
        有方法 add10
        转函数: val a = add10 _
       
        ''
7.  方法可以重载/覆写, 函数不能重载/覆写

8. 以后使用的时候, 不用关注他们的区别, 就把函数和方法当成一个东西来时候.
    如果发现编译不通过, 就改成比较完整的写法
```

## 3. 面向对象

面向对象3大特征

`scala`的面向的理论和`java`完全一样, 具体实现方式不一样

## 3. 类和对象

#### 定义类

```scala
class User1
```

属性只的默认初始化值:

- 数字    0
- 布尔型  false
- 引用型  null